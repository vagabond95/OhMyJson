name: Release

on:
  push:
    tags:
      - 'v*'

env:
  APP_NAME: OhMyJson
  SCHEME: OhMyJson
  DEVELOPER_ID: "Developer ID Application: Jihoon Kim (Q69M5M837A)"
  TEAM_ID: Q69M5M837A
  KEYCHAIN_NAME: build.keychain
  KEYCHAIN_PASSWORD: actions-keychain-password

permissions:
  contents: write

jobs:
  release:
    runs-on: macos-15
    timeout-minutes: 30

    steps:
      # ── Checkout ─────────────────────────────────────────────
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Extract version from tag
        id: version
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$GITHUB_REF_NAME" >> "$GITHUB_OUTPUT"

      # ── Certificate Setup ────────────────────────────────────
      - name: Install Developer ID certificate
        env:
          CERTIFICATE_P12_BASE64: ${{ secrets.CERTIFICATE_P12_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        run: |
          CERTIFICATE_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$CERTIFICATE_P12_BASE64" | base64 --decode > "$CERTIFICATE_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          security import "$CERTIFICATE_PATH" \
            -k "$KEYCHAIN_NAME" \
            -P "$CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productsign

          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          security list-keychains -d user -s "$KEYCHAIN_NAME" login.keychain-db

          echo "Verifying certificate..."
          security find-identity -v -p codesigning "$KEYCHAIN_NAME"

      # ── Resolve Dependencies ─────────────────────────────────
      - name: Resolve SPM dependencies
        run: |
          xcodebuild -resolvePackageDependencies \
            -project "$APP_NAME.xcodeproj" \
            -scheme "$SCHEME"

      # ── Build ────────────────────────────────────────────────
      - name: Build Release
        run: |
          xcodebuild -project "$APP_NAME.xcodeproj" \
            -scheme "$SCHEME" \
            -configuration Release \
            -derivedDataPath ./build \
            -arch arm64 -arch x86_64 \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="$DEVELOPER_ID" \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            OTHER_CODE_SIGN_FLAGS="--timestamp --options runtime" \
            CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO \
            CURRENT_PROJECT_VERSION="${{ github.run_number }}" \
            clean build

      # ── Re-sign Sparkle & Verify ─────────────────────────────
      - name: Re-sign Sparkle framework binaries
        run: |
          APP_PATH="./build/Build/Products/Release/$APP_NAME.app"
          SPARKLE_FW="$APP_PATH/Contents/Frameworks/Sparkle.framework"
          CODESIGN_ARGS=(--force --sign "$DEVELOPER_ID" --timestamp --options runtime)

          if [ ! -d "$SPARKLE_FW" ]; then
            echo "Sparkle.framework not found — skipping re-sign."
          else
            echo "=== Re-signing Sparkle internals (inside-out) ==="

            # 1. Standalone Mach-O binaries in Versions/B
            echo "-- Standalone executables --"
            find "$SPARKLE_FW/Versions/B" -maxdepth 1 -type f -perm +111 ! -name "Sparkle" | while read -r bin; do
              echo "  Signing: $bin"
              codesign "${CODESIGN_ARGS[@]}" "$bin"
            done

            # 2. XPC services
            echo "-- XPC services --"
            find "$SPARKLE_FW/Versions/B" -name "*.xpc" -type d | while read -r xpc; do
              echo "  Signing: $xpc"
              codesign "${CODESIGN_ARGS[@]}" "$xpc"
            done

            # 3. Nested apps (Updater.app)
            echo "-- Nested apps --"
            find "$SPARKLE_FW/Versions/B" -name "*.app" -type d | while read -r app; do
              echo "  Signing: $app"
              codesign "${CODESIGN_ARGS[@]}" "$app"
            done

            # 4. Sparkle.framework itself
            echo "-- Sparkle.framework --"
            codesign "${CODESIGN_ARGS[@]}" "$SPARKLE_FW"
          fi

          # 5. Re-sign main app (must include entitlements for Sparkle XPC mach-lookup)
          echo "=== Re-signing main app ==="
          codesign "${CODESIGN_ARGS[@]}" --entitlements "$APP_NAME/$APP_NAME.entitlements" "$APP_PATH"

      - name: Verify code signature
        run: |
          APP_PATH="./build/Build/Products/Release/$APP_NAME.app"
          SPARKLE_FW="$APP_PATH/Contents/Frameworks/Sparkle.framework"

          # Deep verification
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"
          echo "Deep code signature verified."

          # Verify no ad-hoc signatures remain in Sparkle internals
          if [ -d "$SPARKLE_FW" ]; then
            echo "=== Checking Sparkle binaries for ad-hoc signatures ==="
            ADHOC_FOUND=0

            while IFS= read -r bin; do
              SIG_INFO=$(codesign -dvv "$bin" 2>&1 || true)
              if echo "$SIG_INFO" | grep -q "Signature=adhoc"; then
                echo "ERROR: ad-hoc signature found: $bin"
                ADHOC_FOUND=1
              fi
            done < <(find "$SPARKLE_FW/Versions/B" -type f -perm +111)

            while IFS= read -r bundle; do
              SIG_INFO=$(codesign -dvv "$bundle" 2>&1 || true)
              if echo "$SIG_INFO" | grep -q "Signature=adhoc"; then
                echo "ERROR: ad-hoc signature found: $bundle"
                ADHOC_FOUND=1
              fi
            done < <(find "$SPARKLE_FW/Versions/B" \( -name "*.xpc" -o -name "*.app" \) -type d)

            if [ "$ADHOC_FOUND" -eq 1 ]; then
              echo "Ad-hoc signed binaries detected — notarization will fail."
              exit 1
            fi
            echo "All Sparkle binaries are properly signed."
          fi

      # ── Create DMG ───────────────────────────────────────────
      - name: Install create-dmg
        run: brew install create-dmg

      - name: Create DMG
        id: dmg
        run: |
          APP_PATH="./build/Build/Products/Release/$APP_NAME.app"
          DMG_NAME="${APP_NAME}_v${{ steps.version.outputs.version }}.dmg"

          create-dmg \
            --volname "$APP_NAME" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "${APP_NAME}.app" 150 190 \
            --app-drop-link 450 190 \
            "$DMG_NAME" "$APP_PATH"

          echo "dmg_name=$DMG_NAME" >> "$GITHUB_OUTPUT"

      # ── Sign DMG ─────────────────────────────────────────────
      - name: Sign DMG
        run: |
          codesign --force --sign "$DEVELOPER_ID" --timestamp "${{ steps.dmg.outputs.dmg_name }}"
          codesign --verify --verbose=2 "${{ steps.dmg.outputs.dmg_name }}"

      # ── Notarize ─────────────────────────────────────────────
      - name: Notarize DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          DMG_NAME="${{ steps.dmg.outputs.dmg_name }}"
          MAX_RETRIES=3
          RETRY_DELAY=30

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Notarization attempt $attempt of $MAX_RETRIES..."

            if xcrun notarytool submit "$DMG_NAME" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --team-id "$TEAM_ID" \
              --wait \
              --timeout 600 2>&1 | tee notarytool-output.txt; then

              if grep -q "status: Accepted" notarytool-output.txt; then
                echo "Notarization succeeded."
                break
              fi
            fi

            if [ "$attempt" -eq "$MAX_RETRIES" ]; then
              echo "Notarization failed after $MAX_RETRIES attempts."
              # Print notarization log for debugging
              SUBMISSION_ID=$(grep -oE '[0-9a-f-]{36}' notarytool-output.txt | head -1)
              if [ -n "$SUBMISSION_ID" ]; then
                xcrun notarytool log "$SUBMISSION_ID" \
                  --apple-id "$APPLE_ID" \
                  --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                  --team-id "$TEAM_ID" || true
              fi
              exit 1
            fi

            echo "Retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
            RETRY_DELAY=$((RETRY_DELAY * 2))
          done

      - name: Staple notarization ticket
        run: xcrun stapler staple "${{ steps.dmg.outputs.dmg_name }}"

      # ── Create Sparkle ZIP ────────────────────────────────────
      - name: Create Sparkle update ZIP
        id: zip
        run: |
          APP_PATH="./build/Build/Products/Release/$APP_NAME.app"
          ZIP_NAME="${APP_NAME}_v${{ steps.version.outputs.version }}.zip"
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_NAME"
          echo "zip_name=$ZIP_NAME" >> "$GITHUB_OUTPUT"

      - name: Sign update with EdDSA for Sparkle
        id: sparkle_sign
        env:
          SPARKLE_EDDSA_KEY: ${{ secrets.SPARKLE_EDDSA_KEY }}
        run: |
          ZIP_NAME="${{ steps.zip.outputs.zip_name }}"

          # 1. Validate secret exists
          if [ -z "$SPARKLE_EDDSA_KEY" ]; then
            echo "::error::SPARKLE_EDDSA_KEY secret is not set. Generate with: ./bin/generate_keys (from Sparkle release)"
            exit 1
          fi
          echo "SPARKLE_EDDSA_KEY is set (${#SPARKLE_EDDSA_KEY} chars)"

          # 2. Validate ZIP exists
          if [ ! -f "$ZIP_NAME" ]; then
            echo "::error::ZIP file not found: $ZIP_NAME"
            exit 1
          fi
          echo "ZIP file: $ZIP_NAME ($(stat -f%z "$ZIP_NAME") bytes)"

          # 3. Download official Sparkle release for sign_update
          # SPM artifact binaries don't work reliably as standalone CLI tools
          SPARKLE_VERSION="2.8.1"
          echo "Downloading Sparkle ${SPARKLE_VERSION} for sign_update tool..."
          curl -fSL "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz" \
            -o /tmp/sparkle.tar.xz
          mkdir -p /tmp/sparkle
          tar xJf /tmp/sparkle.tar.xz -C /tmp/sparkle

          SIGN_UPDATE="/tmp/sparkle/bin/sign_update"
          if [ ! -f "$SIGN_UPDATE" ]; then
            echo "::error::sign_update not found after extracting Sparkle release"
            ls -la /tmp/sparkle/bin/ || echo "bin/ directory does not exist"
            ls -la /tmp/sparkle/ || true
            exit 1
          fi

          chmod +x "$SIGN_UPDATE"
          echo "Using sign_update: $SIGN_UPDATE"
          file "$SIGN_UPDATE"

          # 4. Run sign_update (separate stdout/stderr for clean capture)
          printf '%s' "$SPARKLE_EDDSA_KEY" \
            | "$SIGN_UPDATE" "$ZIP_NAME" -f - \
            > /tmp/sign_stdout.txt 2>/tmp/sign_stderr.txt || {
            echo "::error::sign_update exited with code $?"
            echo "--- stderr ---"
            cat /tmp/sign_stderr.txt
            echo "--- stdout ---"
            cat /tmp/sign_stdout.txt
            exit 1
          }

          SIGNATURE=$(cat /tmp/sign_stdout.txt)
          echo "Raw signature output: $SIGNATURE"
          if [ -s /tmp/sign_stderr.txt ]; then
            echo "sign_update warnings:"
            cat /tmp/sign_stderr.txt
          fi

          # 5. Extract and validate edSignature
          ED_SIGNATURE=$(echo "$SIGNATURE" | sed -n 's/.*edSignature="\([^"]*\)".*/\1/p')
          LENGTH=$(stat -f%z "$ZIP_NAME" 2>/dev/null || stat -c%s "$ZIP_NAME")

          if [ -z "$ED_SIGNATURE" ]; then
            echo "::error::Failed to extract edSignature from sign_update output."
            echo "Full output was: $SIGNATURE"
            echo "Hint: SPARKLE_EDDSA_KEY must contain ONLY the base64 private key string, not the full generate_keys output."
            exit 1
          fi

          echo "EdDSA signature: ${ED_SIGNATURE:0:20}..."
          echo "ZIP length: $LENGTH"

          echo "signature=$ED_SIGNATURE" >> "$GITHUB_OUTPUT"
          echo "length=$LENGTH" >> "$GITHUB_OUTPUT"

      # ── Update Appcast ─────────────────────────────────────────
      - name: Update appcast.xml
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUILD="${{ github.run_number }}"
          ZIP_NAME="${{ steps.zip.outputs.zip_name }}"
          ED_SIGNATURE="${{ steps.sparkle_sign.outputs.signature }}"
          LENGTH="${{ steps.sparkle_sign.outputs.length }}"
          DOWNLOAD_URL="https://github.com/vagabond95/OhMyJson/releases/download/v${VERSION}/${ZIP_NAME}"
          PUB_DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")

          # Write new item to temp file (heredoc expands shell variables)
          cat > /tmp/new_appcast_item.xml <<ITEM_EOF
      <item>
        <title>Version ${VERSION}</title>
        <pubDate>${PUB_DATE}</pubDate>
        <sparkle:minimumSystemVersion>14.0</sparkle:minimumSystemVersion>
        <enclosure
          url="${DOWNLOAD_URL}"
          sparkle:version="${BUILD}"
          sparkle:shortVersionString="${VERSION}"
          sparkle:edSignature="${ED_SIGNATURE}"
          length="${LENGTH}"
          type="application/octet-stream" />
      </item>
ITEM_EOF

          # Insert before </channel> using python3 (BSD sed can't handle multi-line substitution)
          python3 -c "
item = open('/tmp/new_appcast_item.xml').read().rstrip('\n')
with open('appcast.xml') as f:
    content = f.read()
content = content.replace('</channel>', item + '\n  </channel>')
with open('appcast.xml', 'w') as f:
    f.write(content)
"

      - name: Commit and push appcast.xml
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add appcast.xml
          if git diff --cached --quiet; then
            echo "No appcast changes to commit."
          else
            git commit -m "Update appcast.xml for v${{ steps.version.outputs.version }}"
            git push origin HEAD:main
          fi

      # ── GitHub Release ───────────────────────────────────────
      - name: Compute SHA256
        id: sha
        run: |
          SHA256=$(shasum -a 256 "${{ steps.dmg.outputs.dmg_name }}" | awk '{print $1}')
          echo "sha256=$SHA256" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          DMG_NAME="${{ steps.dmg.outputs.dmg_name }}"
          ZIP_NAME="${{ steps.zip.outputs.zip_name }}"
          SHA256="${{ steps.sha.outputs.sha256 }}"

          # Extract tag annotation message
          TAG_MSG=$(git tag -l --format='%(contents)' "$TAG" | head -20)
          if [ -z "$TAG_MSG" ]; then
            TAG_MSG="Release $TAG"
          fi

          gh release create "$TAG" "$DMG_NAME" "$ZIP_NAME" \
            --title "$APP_NAME $TAG" \
            --notes "$(cat <<EOF
          $TAG_MSG

          ## Install

          ### Direct Download
          Download \`$DMG_NAME\`, open it, and drag OhMyJson to Applications.

          ### Homebrew
          \`\`\`bash
          brew tap vagabond95/ohmyjson
          brew install --cask ohmyjson
          \`\`\`

          ## Verify

          **SHA256:** \`$SHA256\`

          \`\`\`bash
          shasum -a 256 $DMG_NAME
          \`\`\`
          EOF
          )"

      # ── Homebrew Cask Update ─────────────────────────────────
      - name: Update Homebrew cask
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          SHA256="${{ steps.sha.outputs.sha256 }}"
          CASK_REPO="/tmp/homebrew-ohmyjson"

          git clone "https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/vagabond95/homebrew-ohmyjson.git" "$CASK_REPO"

          sed -i '' "s/version \".*\"/version \"${VERSION}\"/" "$CASK_REPO/Casks/ohmyjson.rb"
          sed -i '' "s/sha256 \".*\"/sha256 \"${SHA256}\"/" "$CASK_REPO/Casks/ohmyjson.rb"

          cd "$CASK_REPO"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Update OhMyJson to v${VERSION}"
          git push

      # ── Cleanup ──────────────────────────────────────────────
      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain "$KEYCHAIN_NAME" 2>/dev/null || true
